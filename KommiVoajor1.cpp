//*****************************************************************
// Filename: func.h
// Abstract: This is a simple c++ program.
// Description: Функции для задачи комивояжера.
// Create Date: 2022 / 05 / 19
// Author: Студент ИРИТ НГТУ Китов А.А. 21-ИВТ-2
// V 3.0
// None//OS Linux//None
//*****************************************************************//
#include <iostream>
#include <string>
#include <fstream>
#include <iomanip>
#include <sstream>
#include <iomanip>
#include <ctime>
#include <cstdlib>
/*****************************************************************/
/*    Функция: make1Mass (n: int) : int*                         */
/*    Цель: выделение памяти под одномерный массив               */
/*    Исходные данные:                                           */
/*         n – количество элементов массива                      */
/*    Результат:    одномерный массив                            */
/*    Вызываемые модули:  нет                                    */
/*    Описание алгоритма:                                        */
/*       создание массива из целочисленных элементов величиной n */
/*    Дата:  2022 / 05 / 16    Версия 1.01                       */
/*    Автор:  Китов А.А.                                         */
/*    Исправления:  нет                                          */
/*****************************************************************/
int* make1Mass(int n){
    int *matr;
    matr=new int[n];
    return matr;
}
/*******************************************************************/
/*    Функция: make2Mass (n: int) : int**                          */
/*    Цель: выделение памяти под двумерный массив                  */
/*    Исходные данные:                                             */
/*         n – количество строк и столбцов массива                 */
/*    Результат:    двумерный массив                               */
/*    Вызываемые модули:  нет                                      */
/*    Описание алгоритма:                                          */
/*       создание массива из целочисленных элементов величиной nxn */
/*    Дата:  2022 / 05 / 16    Версия 1.01                         */
/*    Автор:  Китов А.А.                                           */
/*    Исправления:  нет                                            */
/*******************************************************************/
int** make2Mass(int n){
    int **matr;
    int m=n;
    matr=new int*[n];
    for(int i=0;i<n;i++){
        matr[i]=new int[m];
    }
    return matr;
}
/****************************************************************/
/*    Функция: random (mass: int**; n: int) : int**             */
/*    Цель: заполнение рандомными числами двумерного массива    */
/*    Исходные данные:                                          */
/*         n – количество строк и столбцов массива              */
/*    Результат:    двумерный массив                            */
/*    Вызываемые модули:  нет                                   */
/*    Описание алгоритма:                                       */
/*       с помощью функции srand массив заполняется числами     */
/*    Дата:  2022 / 05 / 16    Версия 1.01                      */
/*    Автор:  Китов А.А.                                        */
/*    Исправления:  нет                                         */
/****************************************************************/
int** random(int** mass, int n){
    srand(time(NULL));
    for(int i=0;i<n;i++){
        for(int g=0;g<n;g++){
            mass[i][g]=rand()%1000+1;
            if(i==g){
                mass[i][g]=-1;
            }
        }
    }
    return mass;
}
/****************************************************************/
/*    Функция: arrCpy (mass1: int**; n: int) : int**            */
/*    Цель: создание нового массива размером nxn и копирование  */
/*          из mass1 элементов                                  */
/*    Исходные данные:                                          */
/*         n – количество строк и столбцов массива              */
/*         mass1- двумерный массив                              */
/*    Результат:    двумерный массив                            */
/*    Вызываемые модули:  нет                                   */
/*    Описание алгоритма:                                       */
/*       создание массива из целочисленных элементов величиной  */
/*       nxn и заполнение его элементами из mass1               */
/*    Дата:  2022 / 05 / 16    Версия 1.01                      */
/*    Автор:  Китов А.А.                                        */
/*    Исправления:  нет                                         */
/****************************************************************/
int** arrCpy(int** mass1, int n){
    int **mass;
    int m=n;
    mass=new int*[n];
    for(int i=0;i<n;i++){
        mass[i]=new int[m];
    }
    for(int g=0;g<n;g++){
        for(int j=0;j<n;j++){
            mass[g][j]=mass1[g][j];
        }
    }
    return mass;
}
/*************************************************************************/
/*    Функция: arrCp (mass1: int**;mass2: int**; n: int) : void             */
/*    Цель: копирование элементов из mass2 в mass1                          */
/*    Исходные данные:                                                      */
/*         n – количество строк и столбцов массива                          */
/*         mass1- двумерный массив                                          */
/*         mass2- двумерный массив                                          */
/*    Результат:    нет                                                     */
/*    Вызываемые модули:  нет                                               */
/*    Описание алгоритма:                                                   */
/*       копирование целочисленного элемента одного массива на соответствен-*/
/*       ную позицию второго массива                                        */
/*    Дата:  2022 / 05 / 16    Версия 1.01                                  */
/*    Автор:  Китов А.А.                                                    */
/*    Исправления:  нет                                                     */
/****************************************************************************/
void arrCp(int** mass1, int** mass2, int n){
    for(int g=0;g<n;g++){
        for(int j=0;j<n;j++){
            mass1[g][j]=mass2[g][j];
        }
    }
}
/************************************************************************/
/*    Функция: arrPlus (mass1: int**; n: int) : int**                   */
/*    Цель: создание нового массива  и копирование из mass1             */
/*          всех элементов                                              */
/*    Исходные данные:                                                  */
/*         n – количество строк и столбцов массива изначального массива */
/*         mass1- двумерный массив                                      */
/*    Результат:    двумерный массив                                    */
/*    Вызываемые модули:  нет                                           */
/*    Описание алгоритма:                                               */
/*       создание массива из целочисленных элементов величиной          */
/*       n+1 x n+1 и заполнение его элементами из mass1                 */
/*    Дата:  2022 / 05 / 16    Версия 1.01                              */
/*    Автор:  Китов А.А.                                                */
/*    Исправления:  нет                                                 */
/************************************************************************/
int** arrPlus(int ** mass1, int n){
    int **mass;
    int m1=n+1;
    int m2=n+1;
    mass=new int*[m1];
    for(int i=0;i<m1;i++){
        mass[i]=new int[m2];
    }
    for(int g=0;g<n;g++){
        for(int j=0;j<n;j++){
            mass[g][j]=mass1[g][j];
            mass[n][g]=0;
            mass[g][n]=0;
        }
    }
    mass[n][n]=0;
    return mass;
}
/***********************************************************************************/
/*    Функция: arrMinRow (mass1: int**; n: int) : int**                            */
/*    Цель: подсчёт минимумов в строках                                            */
/*    Исходные данные:                                                             */
/*         n – количество строк и столбцов массива                                 */
/*         mass1- двумерный массив                                                 */
/*    Результат:    двумерный массив                                               */
/*    Вызываемые модули:  нет                                                      */
/*    Описание алгоритма:                                                          */
/*       нахожение минимума в строке и запись его крайний правый столбец           */
/*       соответственно для каждой строки и вычитание из каждого элемента минимума */
/*    Дата:  2022 / 05 / 16    Версия 1.01                                         */
/*    Автор:  Китов А.А.                                                           */
/*    Исправления:  нет                                                            */
/***********************************************************************************/
int** arrMinRow(int ** mass1, int n){
    int minn=1000;
    for(int g=0;g<n;g++){
        for(int j=0;j<n;j++){
            if(mass1[g][j]>=0 and mass1[g][j]<minn){
                minn=mass1[g][j];
            }
        }
        if(minn!=1000){
            mass1[g][n]=minn;
        }
        else{
            mass1[g][n]=-1;
        }
        minn=1000;
    }
    for(int g=0;g<n;g++){
        for(int j=0;j<n;j++){
            if(mass1[g][j]>=0){
                mass1[g][j]=mass1[g][j]-mass1[g][n];
            }
        }
    }

    return mass1;
}
/*************************************************************************/
/* Функция: arrMinCol (mass1: int**; n: int) : int**                              */
/*    Цель: подсчёт минимумов в столбцах                                             */
/*    Исходные данные:                                                               */
/*         n – количество строк и столбцов массива                                   */
/*         mass1- двумерный массив                                                   */
/*    Результат:    двумерный массив                                                 */
/*    Вызываемые модули:  нет                                                        */
/*    Описание алгоритма:                                                            */
/*       нахожение минимума в столбце и запись его крайний нижнюю строку             */
/*       соответственно для каждого столбца и вычитание из каждого элемента минимума */
/*    Дата:  2022 / 05 / 16    Версия 1.01                                           */
/*    Автор:  Китов А.А.                                                             */
/*    Исправления:  нет                                                              */
/*************************************************************************/
int** arrMinCol(int ** mass1, int n){
    int minn=1000;
    for(int g=0;g<n;g++){
        for(int j=0;j<n;j++){
            if(mass1[j][g]>=0 and mass1[j][g]<minn){
                minn=mass1[j][g];
            }
        }
        if(minn!=1000){
            mass1[n][g]=minn;
        }
        if(minn==1000){
            mass1[n][g]=-1;
        }
        minn=1000;
    }
    for(int g=0;g<n;g++){
        for(int j=0;j<n;j++){
            if(mass1[j][g]>=0){
                mass1[j][g]=mass1[j][g]-mass1[n][g];
            }
        }
    }
    return mass1;
}
/************************************************************************/
/*    Функция: output (mass1: int**; n: int) : void                     */
/*    Цель: вывод в удобном виде всех элементов массива                 */
/*    Исходные данные:                                                  */
/*         n – количество строк и столбцов массива изначального массива */
/*         mass1- двумерный массив                                      */
/*    Результат:    нет                                                 */
/*    Вызываемые модули:  нет                                           */
/*    Описание алгоритма:                                               */
/*       вывод n строк и n столбцов двумерного массива                  */
/*    Дата:  2022 / 05 / 16    Версия 1.01                              */
/*    Автор:  Китов А.А.                                                */
/*    Исправления:  нет                                                 */
/************************************************************************/
void output(int** mass, int n){
    for(int i=0;i<n;i++){
        for(int g=0;g<n;g++){
            std::cout<<std::right<<std::setw(5)<<mass[i][g]<<" ";
        }
        std::cout<<std::endl;
    }
    std::cout<<std::endl<<"------------------------------------------"<<std::endl;
}
void outout(int** mass, int n){
    std::ofstream fout;
    fout.open("otvet.txt",std::ios::app);
    for(int i=0;i<n;i++){
        for(int g=0;g<n;g++){
            fout<<std::right<<std::setw(5)<<mass[i][g]<<" ";
        }
        fout<<std::endl;
    }
    fout<<std::endl<<"------------------------------------------"<<std::endl;
    fout.close();
}
/*************************************************************************/
/*   Функция: deleteColRow (mass1: int**; n: int;i1: int;g1: int) : int** */
/*    Цель: замена всех элементов 1 строки и столбца на -1                 */
/*    Исходные данные:                                                     */
/*         n – количество строк и столбцов массива изначального массива    */
/*         mass1- двумерный массив                                         */
/*         i1- номер строки                                                */
/*         g1- номер столбца                                               */
/*    Результат:    двумерный массив                                       */
/*    Вызываемые модули:  нет                                              */
/*    Описание алгоритма:                                                  */
/*       удаление путя, который мы уже использовали                        */
/*    Дата:  2022 / 05 / 16    Версия 1.01                                 */
/*    Автор:  Китов А.А.                                                   */
/*    Исправления:  нет                                                    */
/*************************************************************************/
int** deleteColRow(int** mass, int n, int i1, int g1){
    for (int i=0;i<n;i++){
        mass[i][i1]=-1;
        mass[g1][i]=-1;
    }
    mass[n][i1]=-1;
    mass[g1][n]=-1;
    mass[i1][g1]=-1;
    return mass;
}
/****************************************************************/
/*    Функция: sum (mass1: int**; n: int) : int                 */
/*    Цель: посчёт суммы элементов крайнего столбца и строки    */
/*          из элементов mass1                                  */
/*    Исходные данные:                                          */
/*         n – количество строк и столбцов массива              */
/*         mass1- двумерный массив                              */
/*    Результат:    двумерный массив                            */
/*    Вызываемые модули:  нет                                   */
/*    Описание алгоритма:                                       */
/*       расчёт суммы минимумов по стокам и столбцам            */
/*    Дата:  2022 / 05 / 16    Версия 1.01                      */
/*    Автор:  Китов А.А.                                        */
/*    Исправления:  нет                                         */
/****************************************************************/
int sum(int** mass, int n) {
    int summa=0;
    for (int i=0;i<n;i++){
        if(mass[i][n]>0){
            summa=summa+mass[i][n];
        }
    }
    for (int i=0;i<n;i++){
        if(mass[i][n]>0){
            summa=summa+mass[n][i];
        }
    }
    return summa;
}



//*****************************************************************
// Filename: main.cpp
// Abstract: This is a simple c++ program.
// Description: Поиск наивыгоднейшего пути методом ветвей и гшраниц.
// Create Date: 2022 / 05 / 19
// Author: Студент ИРИТ НГТУ Китов А.А. 21-ИВТ-2
// V 3.0
// None//OS Linux//None
//*****************************************************************//
#include "func.h"
int main(){
    setlocale (LC_ALL, "rus");
    char logo[] =
            "**********************************************\n"
            "* Nizhny Novgorog State Technical University *\n"
            "* Сourse work number 1.                      *\n"
            "* Performed student 21-IVT-2 Kitov A. A.     *\n"
            "**********************************************\n";
    std::cout<< logo;
    int** arr1;
    int** arr2;
    int** arr3;
    int** arr5;
    int* otvet;
    std::string df;
    int size,minn1=0,minn2=0, ki=0,kg=0,k=0,ktg=0, maxxfor=0,maxxfunc=-1,need=0, N=0,N_=0,N2=0;
    std::ofstream out;
    out.open("otvet.txt",std::ios::app);
    std::cout<<"Введите количество городов:";
    std::cin>>size; /*  Ввод значения количества городов            */
    /****************************************************************/
    /*  Блок проверки введённого значения                           */
    /*  size должен быть больше 0 и соответствовать введённому типу */
    if(std::cin.good() and size>2){
        std::cout<<"Введите тип ввода данных(auto-автоматический с рандомными числами, notauto-ввод с клавиатуры): ";
        std::cin>>df;       /* Ввод варианта действия программы: создание чисел компьютером или их ввод пользователем */
        arr1 = make2Mass(size);                                                /* Создание массива и выделение памяти */
        /******************************************************************/
        /*  Блок определения создания массива(рандомно или пользователем) */
        /*  auto- создание чисел рандомно компьютером                     */
        if(df=="auto") {
            arr1 = random(arr1, size);                                             /*  Рандомное заполнение массива   */
            std::cout << "Изначальная матрица:" << std::endl;
            output(arr1, size);                                                    /*   Вывод заполненного массива    */
            out<<"Количество городов: "<<size<<std::endl<<"Режим auto"<<std::endl<<std::endl;
            out << "Изначальная матрица:" << std::endl;
            outout(arr1, size); 
        }
        /*  notauto- запись чисел с клавиатуры пользолвателем */
        if(df=="notauto"){
            /**************************************************/
            /*  Блок ввода пользователем чисел в матрицу      */
            for(int q=0;q<size;q++){
                if(q==0) {
                    std::cout << "-----------" << std::endl;
                }
                for(int l=0;l<size;l++){
                    if(q!=l) {
                        std::cout << "Путь из " << q + 1 << " " << l + 1 << ":";
                        std::cin >> arr1[q][l];
                        if(arr1[q][l]<=0){                               /* Если вводимое значение меньше или равно 0 */
                            N2=1;       /* Изменение значения переменной N2 на 1  */
                        }
                    }
                    if(q==l){        /* Заполнение главной диагонали значениями -1 */
                        arr1[q][l]=-1;
                    }
                }
                std::cout<<"-----------"<<std::endl;
            }
            /***************************************************/
            out<<"Количество городов: "<<size<<std::endl<<"Режим auto"<<std::endl<<std::endl;
            out << "Изначальная матрица:" << std::endl;
            outout(arr1, size);
        }
        /******************************************************************/
        /******************************************************************/
        /*  Блок определения дальнейшей работы программы                  */
        /*  Если N2(число,которое показывает наличие неправильных данных) */
        /*  значение не изменилось, то начинается расчёт выгодного пути   */
        /*  и ввод типа работы программы верен(т.е. равен auto и notauto) */
        if(N2==0 and (df=="auto" or df=="notauto")) {
            arr2 = arrCpy(arr1, size);
            std::cout << "Скопированный изначальный массив" << std::endl;
            output(arr2, size);
            out << "Скопированный изначальный массив" << std::endl;
            outout(arr2, size);
            arr3 = arrPlus(arr2, size);
            std::cout << "Массив хранения минимумов строк и столбцов" << std::endl;
            output(arr3, size + 1);
            out << "Массив хранения минимумов строк и столбцов" << std::endl;
            outout(arr3, size + 1);
            arr5 = arrPlus(arr2, size);
            /******************************************************************/
            /*  Блок определения путей прохода нашего "торговца" количество   */
            /*  проходок по циклу определяется количеством городов            */
            for (int result = 0; result < size; result++) {
                minn1 = 100000000;
                minn2 = 100000000;
                arr3 = arrMinRow(arr3, size);
                std::cout << "Нахождение минимумов по строкам и их редукция" << std::endl;
                output(arr3, size + 1);
                out << "Нахождение минимумов по строкам и их редукция" << std::endl;
                outout(arr3, size + 1);
                arr3 = arrMinCol(arr3, size);
                std::cout << "Нахождение минимумов по столбцам и их редукция" << std::endl;
                output(arr3, size + 1);
                out << "Нахождение минимумов по столбцам и их редукция" << std::endl;
                outout(arr3, size + 1);
                if (N == 0) {
                    N = sum(arr3, size);
                }
                std::cout << std::endl << "Сумма минимумов N:" << N << std::endl;
                /*******************************************/
                /*  Блок нахожения оценок нулевых клеток   */
                for (int g = 0; g < size; g++) {
                    for (int j = 0; j < size; j++) {
                        if (arr3[g][j] == 0) {
                            for (int i = 0; i < size; i++) {
                                if (arr3[i][j] < minn1 and arr3[i][j] >= 0 and i != g) {   /* Поиск минимума в строке */
                                    minn1 = arr3[i][j];
                                }

                            }
                            for (int i = 0; i < size; i++) {
                                if (arr3[g][i] < minn2 and arr3[g][i] >= 0 and i != j) {  /* Поиск минимума в столбце */ 
                                    minn2 = arr3[g][i];
                                }
                            }
                            maxxfor = minn1 + minn2;
                            if (maxxfor >= maxxfunc) {                        /* Нахожение масимума из всех минимумов */
                                ki = g;
                                kg = j;
                                maxxfunc = maxxfor;
                            }
                            maxxfor = 0;
                            minn1 = 100000000;
                            minn2 = 100000000;
                        }
                    }
                }
                /*****************************************/
                if (maxxfunc != 200000000) {
                    N_ = N + maxxfunc;/* Добавление к общему пути выбранный отрезок*/
                } else {
                    N_ = N;
                }
                std::cout <<  "N_другого варианта пути:" << N_ << std::endl;
                maxxfunc = -1;
                std::cout <<"Нужный путь:"<< kg + 1 << "|" << ki + 1  << std::endl<<std::endl;
                out <<"Нужный путь:"<< kg + 1 << "|" << ki + 1  << std::endl<<std::endl;
                arrCp(arr5, arr3, size + 1);
                std::cout << "Дополнительный массив" << std::endl;
                output(arr5, size + 1);
                out << "Дополнительный массив" << std::endl;
                outout(arr5, size + 1);
                std::cout << "Массив до удаления использованного пути" << std::endl;
                output(arr3, size + 1);
                out << "Массив до удаления использованного пути" << std::endl;
                outout(arr3, size + 1);
                arr3 = deleteColRow(arr3, size, kg, ki);
                std::cout << "Массив после удаления использованного пути" << std::endl;
                output(arr3, size + 1);
                out << "Массив после удаления использованного пути" << std::endl;
                outout(arr3, size + 1);
                /***********************************************************/
                /* Блок иного варианта пути, не учитывающее выбранный путь */
                arr5[kg][ki] = -1;
                arr5 = arrMinRow(arr5, size);                                                                                                
                std::cout << "Дополнительное нахождение минимумов по строкам и их редукция для второго варианта пути" << std::endl;        
                output(arr5, size + 1);                                                                                                     
                arr5 = arrMinCol(arr5, size);                                                                                              
                std::cout << "Дополнительное нахождение минимумов по строкам и их редукция для второго варианта пути" << std::endl;           
                output(arr5, size + 1);                                                                                                   
                out << "Дополнительное нахождение минимумов по строкам и столбцам и их редукция для второго варианта пути" << std::endl;           
                outout(arr5, size + 1);
                N2 = sum(arr5, size);
                std::cout << "N21:" << N2 << std::endl;
                N2 = N2 + N;
                std::cout << "N22:" << N2 << std::endl;
                if (N2 <= N_) {
                    if (result == 0) {
                        otvet = make1Mass((size) * 2);
                    }
                    otvet[k] = kg + 1;
                    otvet[k + 1] = ki + 1;
                    k = k + 2;
                    kg = 0;
                    ki = 0;
                    N = N2;
                } else {
                    arrCp(arr3, arr5, size + 1);
                    result = result - 1;
                }
                /**************************************************/
            }
            /**************************************************/
            int per1 = 0, per2 = 0, per3 = 0, per4 = 0, pern = 0, ok = 0, perf = 0;
            /****************************************************************/
            /*  Блок вывода пути торговца в виде, удобным для пользователя  */
            /*  в консоль, так же вывод соотвествующей длины пути           */
            for (int i = 0; i < size * 2; i++) {
                std::cout << otvet[i] << "|";
                if (i % 2 != 0) {
                    std::cout << "|";
                }
            }
            std::cout << std::endl;
            for (int k = 0; k < size - 1; k = k + 1) {
                per2 = 1;
                per4 = 0;
                for (int x = 0; x < size * 2; x++) {
                    if (per3 == 0) {
                        std::cout << otvet[0] << "->" << otvet[1] << "|";
                        out << otvet[0] << "->" << otvet[1] << "|";
                        pern = otvet[0];
                        per1 = otvet[1];
                        per3 = 1;
                        otvet[0] = 0 - otvet[0];
                        otvet[1] = 0 - otvet[1];
                    }
                    if (otvet[x] == per1 and x % 2 == 0 and x != 0 and x != 1 and per2 == 1) {
                        std::cout << otvet[x] << "->" << otvet[x + 1] << "|";
                        out << otvet[x] << "->" << otvet[x + 1] << "|";
                        per1 = otvet[x + 1];
                        otvet[x] = 0 - otvet[x];
                        otvet[x + 1] = 0 - otvet[x + 1];
                        per2 = 0;
                        per4 = 1;
                    }
                }
            }
            for (int k = 0; k < size - 1; k = k + 1) {
                for (int x = 0; x < size * 2; x++) {
                    if (otvet[x] > 0 and k == 0) {
                        std::cout << per1 << "->" << otvet[x] << "|";
                        out << per1 << "->" << otvet[x] << "|";
                        std::cout << otvet[x] << "->" << otvet[x + 1] << "|";
                        out << otvet[x] << "->" << otvet[x + 1] << "|";
                        per1 = otvet[x + 1];
                        otvet[x] = 0 - otvet[x];
                        otvet[x + 1] = 0 - otvet[x + 1];
                        ok = 1;
                    }
                    if (otvet[x] > 0 and x % 2 == 0 and otvet[x] == per1) {
                        std::cout << otvet[x] << "->" << otvet[x + 1] << "|";
                        out << otvet[x] << "->" << otvet[x + 1] << "|";
                        per1 = otvet[x + 1];
                        otvet[x] = 0 - otvet[x];
                        otvet[x + 1] = 0 - otvet[x + 1];
                    }
                }
            }
            /***************************************************/
            /***************************************************/
            /*  Блок вывода длины наивыгоднейщего маршрута     */
            if (ok != 0) {
                std::cout << per1 << "->" << pern << "|";
                out << per1 << "->" << pern << "|";
            }
            std::cout << std::endl;
            std::cout << "Длина наивыгоднейшего пути:" << N << "у.е.";
            std::cout << std::endl;
            out << std::endl;
            out << "Длина наивыгоднейшего пути:" << N << "у.е.";
            out << std::endl;
            /***************************************************/
        }
        if(N2==1 or (df!="auto" and df!="notauto")){
            std::cout<<"Error!You write not correct number or method"<<std::endl;
        }
        /******************************************************************/
    }
    else{
        std::cout<<"Error!Write correct number."<<std::endl;
    }
    /******************************************************************/
    out.close();
    return 0;
}
